# 异步任务系统设计文档

**版本**: v1.0.0  
**创建时间**: 2025-01-15  
**状态**: 设计完成，待实施  

## 🎯 设计目标

基于FastAPI原生BackgroundTasks构建增强的异步任务系统，提供可靠、高性能、易维护的任务处理能力。

## 🏗️ 系统架构

```
Enhanced Task System Architecture
┌─────────────────────────────────────────────────────────────┐
│                    API Layer                                │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │ Documents   │  │   Tests     │  │  Reports    │         │
│  │     API     │  │    API      │  │    API      │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
├─────────────────────────────────────────────────────────────┤
│                  Task Management Layer                     │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Enhanced Task Manager                     │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │ │
│  │  │   Task      │  │   Retry     │  │  Timeout    │   │ │
│  │  │  Scheduler  │  │  Manager    │  │  Handler    │   │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│                   Execution Layer                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  Process    │  │   Thread    │  │   Async     │         │
│  │    Pool     │  │    Pool     │  │   Tasks     │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
├─────────────────────────────────────────────────────────────┤
│                   Storage Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   Task      │  │   Status    │  │  Metrics    │         │
│  │  Storage    │  │   Cache     │  │  Storage    │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

## 📊 核心组件设计

### 1. 任务数据模型

```python
# app/core/tasks/models.py

from enum import Enum
from datetime import datetime
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field

class TaskStatus(str, Enum):
    """任务状态枚举"""
    PENDING = "pending"      # 等待执行
    RUNNING = "running"      # 正在执行
    COMPLETED = "completed"  # 执行完成
    FAILED = "failed"        # 执行失败
    RETRYING = "retrying"    # 重试中
    CANCELLED = "cancelled"  # 已取消
    TIMEOUT = "timeout"      # 执行超时

class TaskType(str, Enum):
    """任务类型枚举"""
    DOCUMENT_ANALYSIS = "document_analysis"
    TEST_GENERATION = "test_generation"
    TEST_EXECUTION = "test_execution"
    REPORT_GENERATION = "report_generation"

class TaskPriority(int, Enum):
    """任务优先级"""
    LOW = 1
    NORMAL = 5
    HIGH = 10
    URGENT = 20

class TaskModel(BaseModel):
    """任务数据模型"""
    task_id: str = Field(description="任务唯一标识")
    task_type: TaskType = Field(description="任务类型")
    status: TaskStatus = Field(default=TaskStatus.PENDING, description="任务状态")
    priority: TaskPriority = Field(default=TaskPriority.NORMAL, description="任务优先级")
    
    # 时间信息
    created_at: datetime = Field(description="创建时间")
    started_at: Optional[datetime] = Field(default=None, description="开始时间")
    completed_at: Optional[datetime] = Field(default=None, description="完成时间")
    
    # 任务数据
    input_data: Dict[str, Any] = Field(description="输入数据")
    result_data: Optional[Dict[str, Any]] = Field(default=None, description="结果数据")
    error_info: Optional[Dict[str, Any]] = Field(default=None, description="错误信息")
    
    # 执行信息
    retry_count: int = Field(default=0, description="重试次数")
    max_retries: int = Field(default=3, description="最大重试次数")
    timeout_seconds: int = Field(default=300, description="超时时间(秒)")
    
    # 元数据
    metadata: Dict[str, Any] = Field(default_factory=dict, description="元数据")
    
    class Config:
        use_enum_values = True
```

### 2. 任务存储接口

```python
# app/core/tasks/storage.py

from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any
from .models import TaskModel, TaskStatus, TaskType

class TaskStorageInterface(ABC):
    """任务存储接口 - 支持PostgreSQL/SQLite"""
    
    @abstractmethod
    async def create_task(self, task: TaskModel) -> str:
        """创建任务"""
        pass
    
    @abstractmethod
    async def get_task(self, task_id: str) -> Optional[TaskModel]:
        """获取任务"""
        pass
    
    @abstractmethod
    async def update_task_status(self, task_id: str, status: TaskStatus, 
                               result_data: Optional[Dict[str, Any]] = None,
                               error_info: Optional[Dict[str, Any]] = None) -> bool:
        """更新任务状态"""
        pass
    
    @abstractmethod
    async def list_tasks(self, task_type: Optional[TaskType] = None,
                        status: Optional[TaskStatus] = None,
                        limit: int = 100, offset: int = 0) -> List[TaskModel]:
        """获取任务列表"""
        pass
    
    @abstractmethod
    async def get_task_statistics(self) -> Dict[str, Any]:
        """获取任务统计"""
        pass
```

### 3. 增强任务管理器

```python
# app/core/tasks/manager.py

import asyncio
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, Callable, Awaitable
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor

from .models import TaskModel, TaskStatus, TaskType, TaskPriority
from .storage import TaskStorageInterface
from .retry import RetryManager
from .timeout import TimeoutManager
from .monitor import TaskMonitor

class EnhancedTaskManager:
    """增强任务管理器"""
    
    def __init__(self, 
                 storage: TaskStorageInterface,
                 max_cpu_workers: int = 4,
                 max_io_workers: int = 16):
        self.storage = storage
        self.retry_manager = RetryManager()
        self.timeout_manager = TimeoutManager()
        self.monitor = TaskMonitor()
        
        # 执行器池
        self.cpu_executor = ProcessPoolExecutor(max_workers=max_cpu_workers)
        self.io_executor = ThreadPoolExecutor(max_workers=max_io_workers)
        
        # 任务注册表
        self.task_handlers: Dict[TaskType, Callable] = {}
        
        # 运行状态
        self.running_tasks: Dict[str, asyncio.Task] = {}
        
    def register_handler(self, task_type: TaskType, handler: Callable):
        """注册任务处理器"""
        self.task_handlers[task_type] = handler
    
    async def submit_task(self, 
                         task_type: TaskType,
                         input_data: Dict[str, Any],
                         priority: TaskPriority = TaskPriority.NORMAL,
                         timeout_seconds: int = 300,
                         max_retries: int = 3) -> str:
        """提交任务"""
        
        # 创建任务模型
        task = TaskModel(
            task_id=str(uuid.uuid4()),
            task_type=task_type,
            priority=priority,
            created_at=datetime.now(),
            input_data=input_data,
            timeout_seconds=timeout_seconds,
            max_retries=max_retries
        )
        
        # 保存到存储
        await self.storage.create_task(task)
        
        # 异步执行
        asyncio.create_task(self._execute_task(task.task_id))
        
        return task.task_id
    
    async def _execute_task(self, task_id: str):
        """执行任务"""
        try:
            # 获取任务
            task = await self.storage.get_task(task_id)
            if not task:
                return
            
            # 检查处理器
            handler = self.task_handlers.get(task.task_type)
            if not handler:
                await self._mark_task_failed(task_id, "No handler registered")
                return
            
            # 更新状态为运行中
            await self.storage.update_task_status(task_id, TaskStatus.RUNNING)
            await self.storage.update_task_status(task_id, TaskStatus.RUNNING, 
                                                result_data={"started_at": datetime.now().isoformat()})
            
            # 执行任务（带超时和重试）
            result = await self._execute_with_timeout_and_retry(task, handler)
            
            # 更新完成状态
            await self.storage.update_task_status(
                task_id, TaskStatus.COMPLETED, 
                result_data={"completed_at": datetime.now().isoformat(), "result": result}
            )
            
            # 记录监控指标
            self.monitor.record_task_completion(task_id, success=True)
            
        except Exception as e:
            await self._mark_task_failed(task_id, str(e))
            self.monitor.record_task_completion(task_id, success=False, error=str(e))
        
        finally:
            # 清理运行任务记录
            self.running_tasks.pop(task_id, None)
    
    async def _execute_with_timeout_and_retry(self, task: TaskModel, handler: Callable) -> Any:
        """带超时和重试的任务执行"""
        
        for attempt in range(task.max_retries + 1):
            try:
                # 执行任务（带超时）
                result = await self.timeout_manager.execute_with_timeout(
                    handler(task.input_data), 
                    timeout_seconds=task.timeout_seconds
                )
                return result
                
            except asyncio.TimeoutError:
                if attempt < task.max_retries:
                    await self._handle_retry(task.task_id, attempt + 1, "Timeout")
                    await self.retry_manager.wait_for_retry(attempt)
                else:
                    raise
                    
            except Exception as e:
                if attempt < task.max_retries and self.retry_manager.should_retry(e):
                    await self._handle_retry(task.task_id, attempt + 1, str(e))
                    await self.retry_manager.wait_for_retry(attempt)
                else:
                    raise
    
    async def _handle_retry(self, task_id: str, retry_count: int, error_msg: str):
        """处理重试"""
        await self.storage.update_task_status(
            task_id, TaskStatus.RETRYING,
            error_info={
                "retry_count": retry_count,
                "last_error": error_msg,
                "retry_at": datetime.now().isoformat()
            }
        )
    
    async def _mark_task_failed(self, task_id: str, error_msg: str):
        """标记任务失败"""
        await self.storage.update_task_status(
            task_id, TaskStatus.FAILED,
            error_info={
                "error": error_msg,
                "failed_at": datetime.now().isoformat()
            }
        )
    
    async def get_task_status(self, task_id: str) -> Optional[TaskModel]:
        """获取任务状态"""
        return await self.storage.get_task(task_id)
    
    async def cancel_task(self, task_id: str) -> bool:
        """取消任务"""
        # 取消运行中的任务
        if task_id in self.running_tasks:
            self.running_tasks[task_id].cancel()
        
        # 更新状态
        return await self.storage.update_task_status(task_id, TaskStatus.CANCELLED)
    
    async def get_task_statistics(self) -> Dict[str, Any]:
        """获取任务统计"""
        storage_stats = await self.storage.get_task_statistics()
        monitor_stats = self.monitor.get_statistics()
        
        return {
            **storage_stats,
            **monitor_stats,
            "running_tasks": len(self.running_tasks),
            "cpu_workers": self.cpu_executor._max_workers,
            "io_workers": self.io_executor._max_workers
        }
    
    async def cleanup(self):
        """清理资源"""
        # 取消所有运行中的任务
        for task in self.running_tasks.values():
            task.cancel()
        
        # 关闭执行器
        self.cpu_executor.shutdown(wait=True)
        self.io_executor.shutdown(wait=True)
```

## 🔄 重试机制设计

```python
# app/core/tasks/retry.py

import asyncio
import random
from typing import Type, List
from datetime import datetime, timedelta

class RetryManager:
    """重试管理器"""
    
    def __init__(self):
        # 可重试的异常类型
        self.retryable_exceptions = [
            ConnectionError,
            TimeoutError,
            # 可以添加更多可重试的异常
        ]
    
    def should_retry(self, exception: Exception) -> bool:
        """判断是否应该重试"""
        return any(isinstance(exception, exc_type) for exc_type in self.retryable_exceptions)
    
    async def wait_for_retry(self, attempt: int, base_delay: float = 1.0, max_delay: float = 60.0):
        """等待重试（指数退避 + 随机抖动）"""
        # 指数退避
        delay = min(base_delay * (2 ** attempt), max_delay)
        
        # 添加随机抖动（避免雷群效应）
        jitter = random.uniform(0.1, 0.3) * delay
        total_delay = delay + jitter
        
        await asyncio.sleep(total_delay)
```

## ⏱️ 超时处理设计

```python
# app/core/tasks/timeout.py

import asyncio
from typing import Any, Awaitable

class TimeoutManager:
    """超时管理器"""
    
    async def execute_with_timeout(self, coro: Awaitable[Any], timeout_seconds: int) -> Any:
        """带超时的协程执行"""
        try:
            return await asyncio.wait_for(coro, timeout=timeout_seconds)
        except asyncio.TimeoutError:
            raise asyncio.TimeoutError(f"Task timed out after {timeout_seconds} seconds")
```

## 📊 监控系统设计

```python
# app/core/tasks/monitor.py

import time
from collections import defaultdict, deque
from typing import Dict, Any, Optional
from datetime import datetime, timedelta

class TaskMonitor:
    """任务监控器"""
    
    def __init__(self, max_history: int = 1000):
        self.max_history = max_history
        
        # 执行统计
        self.execution_times = deque(maxlen=max_history)
        self.success_count = 0
        self.failure_count = 0
        
        # 错误统计
        self.error_counts = defaultdict(int)
        
        # 性能指标
        self.start_time = time.time()
    
    def record_task_completion(self, task_id: str, success: bool, 
                             execution_time: Optional[float] = None,
                             error: Optional[str] = None):
        """记录任务完成"""
        if success:
            self.success_count += 1
        else:
            self.failure_count += 1
            if error:
                self.error_counts[error] += 1
        
        if execution_time:
            self.execution_times.append(execution_time)
    
    def get_statistics(self) -> Dict[str, Any]:
        """获取统计信息"""
        total_tasks = self.success_count + self.failure_count
        success_rate = (self.success_count / total_tasks * 100) if total_tasks > 0 else 0
        
        avg_execution_time = (
            sum(self.execution_times) / len(self.execution_times) 
            if self.execution_times else 0
        )
        
        return {
            "total_tasks": total_tasks,
            "success_count": self.success_count,
            "failure_count": self.failure_count,
            "success_rate": round(success_rate, 2),
            "avg_execution_time": round(avg_execution_time, 3),
            "uptime_seconds": int(time.time() - self.start_time),
            "top_errors": dict(list(self.error_counts.items())[:5])
        }
```

## 🎯 集成方案

### API层集成
```python
# 在现有API端点中集成增强任务管理器

from app.core.tasks.manager import EnhancedTaskManager
from app.core.tasks.models import TaskType

# 全局任务管理器实例
task_manager = EnhancedTaskManager(storage=get_task_storage())

@router.post("/{document_id}/analyze")
async def analyze_document(document_id: str, config: AnalysisConfig):
    # 提交异步任务
    task_id = await task_manager.submit_task(
        task_type=TaskType.DOCUMENT_ANALYSIS,
        input_data={
            "document_id": document_id,
            "config": config.dict()
        },
        timeout_seconds=300,
        max_retries=3
    )
    
    return {
        "task_id": task_id,
        "status": "submitted",
        "message": "文档分析任务已提交"
    }
```

## 📈 性能优化

### 1. 执行器选择策略
```python
# CPU密集型任务使用进程池
cpu_intensive_tasks = [
    TaskType.DOCUMENT_ANALYSIS,
    TaskType.REPORT_GENERATION
]

# I/O密集型任务使用线程池
io_intensive_tasks = [
    TaskType.TEST_EXECUTION
]
```

### 2. 内存优化
```python
# 任务结果清理策略
- 完成任务保留7天
- 失败任务保留30天
- 大结果数据异步清理
```

## 🚀 部署配置

### 环境变量
```bash
# 任务系统配置
TASK_MAX_CPU_WORKERS=4
TASK_MAX_IO_WORKERS=16
TASK_DEFAULT_TIMEOUT=300
TASK_MAX_RETRIES=3
TASK_CLEANUP_DAYS=7
```

---

**文档状态**: 设计完成，准备实施  
**下一步**: 开始编码实现各个组件  
**预计完成**: 1天内完成核心功能
