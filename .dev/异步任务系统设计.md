# å¼‚æ­¥ä»»åŠ¡ç³»ç»Ÿè®¾è®¡æ–‡æ¡£

**ç‰ˆæœ¬**: v1.0.0  
**åˆ›å»ºæ—¶é—´**: 2025-01-15  
**çŠ¶æ€**: è®¾è®¡å®Œæˆï¼Œå¾…å®æ–½  

## ğŸ¯ è®¾è®¡ç›®æ ‡

åŸºäºFastAPIåŸç”ŸBackgroundTasksæ„å»ºå¢å¼ºçš„å¼‚æ­¥ä»»åŠ¡ç³»ç»Ÿï¼Œæä¾›å¯é ã€é«˜æ€§èƒ½ã€æ˜“ç»´æŠ¤çš„ä»»åŠ¡å¤„ç†èƒ½åŠ›ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

```
Enhanced Task System Architecture
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API Layer                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ Documents   â”‚  â”‚   Tests     â”‚  â”‚  Reports    â”‚         â”‚
â”‚  â”‚     API     â”‚  â”‚    API      â”‚  â”‚    API      â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  Task Management Layer                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              Enhanced Task Manager                     â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚   Task      â”‚  â”‚   Retry     â”‚  â”‚  Timeout    â”‚   â”‚ â”‚
â”‚  â”‚  â”‚  Scheduler  â”‚  â”‚  Manager    â”‚  â”‚  Handler    â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Execution Layer                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚  Process    â”‚  â”‚   Thread    â”‚  â”‚   Async     â”‚         â”‚
â”‚  â”‚    Pool     â”‚  â”‚    Pool     â”‚  â”‚   Tasks     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   Storage Layer                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   Task      â”‚  â”‚   Status    â”‚  â”‚  Metrics    â”‚         â”‚
â”‚  â”‚  Storage    â”‚  â”‚   Cache     â”‚  â”‚  Storage    â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. ä»»åŠ¡æ•°æ®æ¨¡å‹

```python
# app/core/tasks/models.py

from enum import Enum
from datetime import datetime
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field

class TaskStatus(str, Enum):
    """ä»»åŠ¡çŠ¶æ€æšä¸¾"""
    PENDING = "pending"      # ç­‰å¾…æ‰§è¡Œ
    RUNNING = "running"      # æ­£åœ¨æ‰§è¡Œ
    COMPLETED = "completed"  # æ‰§è¡Œå®Œæˆ
    FAILED = "failed"        # æ‰§è¡Œå¤±è´¥
    RETRYING = "retrying"    # é‡è¯•ä¸­
    CANCELLED = "cancelled"  # å·²å–æ¶ˆ
    TIMEOUT = "timeout"      # æ‰§è¡Œè¶…æ—¶

class TaskType(str, Enum):
    """ä»»åŠ¡ç±»å‹æšä¸¾"""
    DOCUMENT_ANALYSIS = "document_analysis"
    TEST_GENERATION = "test_generation"
    TEST_EXECUTION = "test_execution"
    REPORT_GENERATION = "report_generation"

class TaskPriority(int, Enum):
    """ä»»åŠ¡ä¼˜å…ˆçº§"""
    LOW = 1
    NORMAL = 5
    HIGH = 10
    URGENT = 20

class TaskModel(BaseModel):
    """ä»»åŠ¡æ•°æ®æ¨¡å‹"""
    task_id: str = Field(description="ä»»åŠ¡å”¯ä¸€æ ‡è¯†")
    task_type: TaskType = Field(description="ä»»åŠ¡ç±»å‹")
    status: TaskStatus = Field(default=TaskStatus.PENDING, description="ä»»åŠ¡çŠ¶æ€")
    priority: TaskPriority = Field(default=TaskPriority.NORMAL, description="ä»»åŠ¡ä¼˜å…ˆçº§")
    
    # æ—¶é—´ä¿¡æ¯
    created_at: datetime = Field(description="åˆ›å»ºæ—¶é—´")
    started_at: Optional[datetime] = Field(default=None, description="å¼€å§‹æ—¶é—´")
    completed_at: Optional[datetime] = Field(default=None, description="å®Œæˆæ—¶é—´")
    
    # ä»»åŠ¡æ•°æ®
    input_data: Dict[str, Any] = Field(description="è¾“å…¥æ•°æ®")
    result_data: Optional[Dict[str, Any]] = Field(default=None, description="ç»“æœæ•°æ®")
    error_info: Optional[Dict[str, Any]] = Field(default=None, description="é”™è¯¯ä¿¡æ¯")
    
    # æ‰§è¡Œä¿¡æ¯
    retry_count: int = Field(default=0, description="é‡è¯•æ¬¡æ•°")
    max_retries: int = Field(default=3, description="æœ€å¤§é‡è¯•æ¬¡æ•°")
    timeout_seconds: int = Field(default=300, description="è¶…æ—¶æ—¶é—´(ç§’)")
    
    # å…ƒæ•°æ®
    metadata: Dict[str, Any] = Field(default_factory=dict, description="å…ƒæ•°æ®")
    
    class Config:
        use_enum_values = True
```

### 2. ä»»åŠ¡å­˜å‚¨æ¥å£

```python
# app/core/tasks/storage.py

from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any
from .models import TaskModel, TaskStatus, TaskType

class TaskStorageInterface(ABC):
    """ä»»åŠ¡å­˜å‚¨æ¥å£ - æ”¯æŒPostgreSQL/SQLite"""
    
    @abstractmethod
    async def create_task(self, task: TaskModel) -> str:
        """åˆ›å»ºä»»åŠ¡"""
        pass
    
    @abstractmethod
    async def get_task(self, task_id: str) -> Optional[TaskModel]:
        """è·å–ä»»åŠ¡"""
        pass
    
    @abstractmethod
    async def update_task_status(self, task_id: str, status: TaskStatus, 
                               result_data: Optional[Dict[str, Any]] = None,
                               error_info: Optional[Dict[str, Any]] = None) -> bool:
        """æ›´æ–°ä»»åŠ¡çŠ¶æ€"""
        pass
    
    @abstractmethod
    async def list_tasks(self, task_type: Optional[TaskType] = None,
                        status: Optional[TaskStatus] = None,
                        limit: int = 100, offset: int = 0) -> List[TaskModel]:
        """è·å–ä»»åŠ¡åˆ—è¡¨"""
        pass
    
    @abstractmethod
    async def get_task_statistics(self) -> Dict[str, Any]:
        """è·å–ä»»åŠ¡ç»Ÿè®¡"""
        pass
```

### 3. å¢å¼ºä»»åŠ¡ç®¡ç†å™¨

```python
# app/core/tasks/manager.py

import asyncio
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, Callable, Awaitable
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor

from .models import TaskModel, TaskStatus, TaskType, TaskPriority
from .storage import TaskStorageInterface
from .retry import RetryManager
from .timeout import TimeoutManager
from .monitor import TaskMonitor

class EnhancedTaskManager:
    """å¢å¼ºä»»åŠ¡ç®¡ç†å™¨"""
    
    def __init__(self, 
                 storage: TaskStorageInterface,
                 max_cpu_workers: int = 4,
                 max_io_workers: int = 16):
        self.storage = storage
        self.retry_manager = RetryManager()
        self.timeout_manager = TimeoutManager()
        self.monitor = TaskMonitor()
        
        # æ‰§è¡Œå™¨æ± 
        self.cpu_executor = ProcessPoolExecutor(max_workers=max_cpu_workers)
        self.io_executor = ThreadPoolExecutor(max_workers=max_io_workers)
        
        # ä»»åŠ¡æ³¨å†Œè¡¨
        self.task_handlers: Dict[TaskType, Callable] = {}
        
        # è¿è¡ŒçŠ¶æ€
        self.running_tasks: Dict[str, asyncio.Task] = {}
        
    def register_handler(self, task_type: TaskType, handler: Callable):
        """æ³¨å†Œä»»åŠ¡å¤„ç†å™¨"""
        self.task_handlers[task_type] = handler
    
    async def submit_task(self, 
                         task_type: TaskType,
                         input_data: Dict[str, Any],
                         priority: TaskPriority = TaskPriority.NORMAL,
                         timeout_seconds: int = 300,
                         max_retries: int = 3) -> str:
        """æäº¤ä»»åŠ¡"""
        
        # åˆ›å»ºä»»åŠ¡æ¨¡å‹
        task = TaskModel(
            task_id=str(uuid.uuid4()),
            task_type=task_type,
            priority=priority,
            created_at=datetime.now(),
            input_data=input_data,
            timeout_seconds=timeout_seconds,
            max_retries=max_retries
        )
        
        # ä¿å­˜åˆ°å­˜å‚¨
        await self.storage.create_task(task)
        
        # å¼‚æ­¥æ‰§è¡Œ
        asyncio.create_task(self._execute_task(task.task_id))
        
        return task.task_id
    
    async def _execute_task(self, task_id: str):
        """æ‰§è¡Œä»»åŠ¡"""
        try:
            # è·å–ä»»åŠ¡
            task = await self.storage.get_task(task_id)
            if not task:
                return
            
            # æ£€æŸ¥å¤„ç†å™¨
            handler = self.task_handlers.get(task.task_type)
            if not handler:
                await self._mark_task_failed(task_id, "No handler registered")
                return
            
            # æ›´æ–°çŠ¶æ€ä¸ºè¿è¡Œä¸­
            await self.storage.update_task_status(task_id, TaskStatus.RUNNING)
            await self.storage.update_task_status(task_id, TaskStatus.RUNNING, 
                                                result_data={"started_at": datetime.now().isoformat()})
            
            # æ‰§è¡Œä»»åŠ¡ï¼ˆå¸¦è¶…æ—¶å’Œé‡è¯•ï¼‰
            result = await self._execute_with_timeout_and_retry(task, handler)
            
            # æ›´æ–°å®ŒæˆçŠ¶æ€
            await self.storage.update_task_status(
                task_id, TaskStatus.COMPLETED, 
                result_data={"completed_at": datetime.now().isoformat(), "result": result}
            )
            
            # è®°å½•ç›‘æ§æŒ‡æ ‡
            self.monitor.record_task_completion(task_id, success=True)
            
        except Exception as e:
            await self._mark_task_failed(task_id, str(e))
            self.monitor.record_task_completion(task_id, success=False, error=str(e))
        
        finally:
            # æ¸…ç†è¿è¡Œä»»åŠ¡è®°å½•
            self.running_tasks.pop(task_id, None)
    
    async def _execute_with_timeout_and_retry(self, task: TaskModel, handler: Callable) -> Any:
        """å¸¦è¶…æ—¶å’Œé‡è¯•çš„ä»»åŠ¡æ‰§è¡Œ"""
        
        for attempt in range(task.max_retries + 1):
            try:
                # æ‰§è¡Œä»»åŠ¡ï¼ˆå¸¦è¶…æ—¶ï¼‰
                result = await self.timeout_manager.execute_with_timeout(
                    handler(task.input_data), 
                    timeout_seconds=task.timeout_seconds
                )
                return result
                
            except asyncio.TimeoutError:
                if attempt < task.max_retries:
                    await self._handle_retry(task.task_id, attempt + 1, "Timeout")
                    await self.retry_manager.wait_for_retry(attempt)
                else:
                    raise
                    
            except Exception as e:
                if attempt < task.max_retries and self.retry_manager.should_retry(e):
                    await self._handle_retry(task.task_id, attempt + 1, str(e))
                    await self.retry_manager.wait_for_retry(attempt)
                else:
                    raise
    
    async def _handle_retry(self, task_id: str, retry_count: int, error_msg: str):
        """å¤„ç†é‡è¯•"""
        await self.storage.update_task_status(
            task_id, TaskStatus.RETRYING,
            error_info={
                "retry_count": retry_count,
                "last_error": error_msg,
                "retry_at": datetime.now().isoformat()
            }
        )
    
    async def _mark_task_failed(self, task_id: str, error_msg: str):
        """æ ‡è®°ä»»åŠ¡å¤±è´¥"""
        await self.storage.update_task_status(
            task_id, TaskStatus.FAILED,
            error_info={
                "error": error_msg,
                "failed_at": datetime.now().isoformat()
            }
        )
    
    async def get_task_status(self, task_id: str) -> Optional[TaskModel]:
        """è·å–ä»»åŠ¡çŠ¶æ€"""
        return await self.storage.get_task(task_id)
    
    async def cancel_task(self, task_id: str) -> bool:
        """å–æ¶ˆä»»åŠ¡"""
        # å–æ¶ˆè¿è¡Œä¸­çš„ä»»åŠ¡
        if task_id in self.running_tasks:
            self.running_tasks[task_id].cancel()
        
        # æ›´æ–°çŠ¶æ€
        return await self.storage.update_task_status(task_id, TaskStatus.CANCELLED)
    
    async def get_task_statistics(self) -> Dict[str, Any]:
        """è·å–ä»»åŠ¡ç»Ÿè®¡"""
        storage_stats = await self.storage.get_task_statistics()
        monitor_stats = self.monitor.get_statistics()
        
        return {
            **storage_stats,
            **monitor_stats,
            "running_tasks": len(self.running_tasks),
            "cpu_workers": self.cpu_executor._max_workers,
            "io_workers": self.io_executor._max_workers
        }
    
    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        # å–æ¶ˆæ‰€æœ‰è¿è¡Œä¸­çš„ä»»åŠ¡
        for task in self.running_tasks.values():
            task.cancel()
        
        # å…³é—­æ‰§è¡Œå™¨
        self.cpu_executor.shutdown(wait=True)
        self.io_executor.shutdown(wait=True)
```

## ğŸ”„ é‡è¯•æœºåˆ¶è®¾è®¡

```python
# app/core/tasks/retry.py

import asyncio
import random
from typing import Type, List
from datetime import datetime, timedelta

class RetryManager:
    """é‡è¯•ç®¡ç†å™¨"""
    
    def __init__(self):
        # å¯é‡è¯•çš„å¼‚å¸¸ç±»å‹
        self.retryable_exceptions = [
            ConnectionError,
            TimeoutError,
            # å¯ä»¥æ·»åŠ æ›´å¤šå¯é‡è¯•çš„å¼‚å¸¸
        ]
    
    def should_retry(self, exception: Exception) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•"""
        return any(isinstance(exception, exc_type) for exc_type in self.retryable_exceptions)
    
    async def wait_for_retry(self, attempt: int, base_delay: float = 1.0, max_delay: float = 60.0):
        """ç­‰å¾…é‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ + éšæœºæŠ–åŠ¨ï¼‰"""
        # æŒ‡æ•°é€€é¿
        delay = min(base_delay * (2 ** attempt), max_delay)
        
        # æ·»åŠ éšæœºæŠ–åŠ¨ï¼ˆé¿å…é›·ç¾¤æ•ˆåº”ï¼‰
        jitter = random.uniform(0.1, 0.3) * delay
        total_delay = delay + jitter
        
        await asyncio.sleep(total_delay)
```

## â±ï¸ è¶…æ—¶å¤„ç†è®¾è®¡

```python
# app/core/tasks/timeout.py

import asyncio
from typing import Any, Awaitable

class TimeoutManager:
    """è¶…æ—¶ç®¡ç†å™¨"""
    
    async def execute_with_timeout(self, coro: Awaitable[Any], timeout_seconds: int) -> Any:
        """å¸¦è¶…æ—¶çš„åç¨‹æ‰§è¡Œ"""
        try:
            return await asyncio.wait_for(coro, timeout=timeout_seconds)
        except asyncio.TimeoutError:
            raise asyncio.TimeoutError(f"Task timed out after {timeout_seconds} seconds")
```

## ğŸ“Š ç›‘æ§ç³»ç»Ÿè®¾è®¡

```python
# app/core/tasks/monitor.py

import time
from collections import defaultdict, deque
from typing import Dict, Any, Optional
from datetime import datetime, timedelta

class TaskMonitor:
    """ä»»åŠ¡ç›‘æ§å™¨"""
    
    def __init__(self, max_history: int = 1000):
        self.max_history = max_history
        
        # æ‰§è¡Œç»Ÿè®¡
        self.execution_times = deque(maxlen=max_history)
        self.success_count = 0
        self.failure_count = 0
        
        # é”™è¯¯ç»Ÿè®¡
        self.error_counts = defaultdict(int)
        
        # æ€§èƒ½æŒ‡æ ‡
        self.start_time = time.time()
    
    def record_task_completion(self, task_id: str, success: bool, 
                             execution_time: Optional[float] = None,
                             error: Optional[str] = None):
        """è®°å½•ä»»åŠ¡å®Œæˆ"""
        if success:
            self.success_count += 1
        else:
            self.failure_count += 1
            if error:
                self.error_counts[error] += 1
        
        if execution_time:
            self.execution_times.append(execution_time)
    
    def get_statistics(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        total_tasks = self.success_count + self.failure_count
        success_rate = (self.success_count / total_tasks * 100) if total_tasks > 0 else 0
        
        avg_execution_time = (
            sum(self.execution_times) / len(self.execution_times) 
            if self.execution_times else 0
        )
        
        return {
            "total_tasks": total_tasks,
            "success_count": self.success_count,
            "failure_count": self.failure_count,
            "success_rate": round(success_rate, 2),
            "avg_execution_time": round(avg_execution_time, 3),
            "uptime_seconds": int(time.time() - self.start_time),
            "top_errors": dict(list(self.error_counts.items())[:5])
        }
```

## ğŸ¯ é›†æˆæ–¹æ¡ˆ

### APIå±‚é›†æˆ
```python
# åœ¨ç°æœ‰APIç«¯ç‚¹ä¸­é›†æˆå¢å¼ºä»»åŠ¡ç®¡ç†å™¨

from app.core.tasks.manager import EnhancedTaskManager
from app.core.tasks.models import TaskType

# å…¨å±€ä»»åŠ¡ç®¡ç†å™¨å®ä¾‹
task_manager = EnhancedTaskManager(storage=get_task_storage())

@router.post("/{document_id}/analyze")
async def analyze_document(document_id: str, config: AnalysisConfig):
    # æäº¤å¼‚æ­¥ä»»åŠ¡
    task_id = await task_manager.submit_task(
        task_type=TaskType.DOCUMENT_ANALYSIS,
        input_data={
            "document_id": document_id,
            "config": config.dict()
        },
        timeout_seconds=300,
        max_retries=3
    )
    
    return {
        "task_id": task_id,
        "status": "submitted",
        "message": "æ–‡æ¡£åˆ†æä»»åŠ¡å·²æäº¤"
    }
```

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### 1. æ‰§è¡Œå™¨é€‰æ‹©ç­–ç•¥
```python
# CPUå¯†é›†å‹ä»»åŠ¡ä½¿ç”¨è¿›ç¨‹æ± 
cpu_intensive_tasks = [
    TaskType.DOCUMENT_ANALYSIS,
    TaskType.REPORT_GENERATION
]

# I/Oå¯†é›†å‹ä»»åŠ¡ä½¿ç”¨çº¿ç¨‹æ± 
io_intensive_tasks = [
    TaskType.TEST_EXECUTION
]
```

### 2. å†…å­˜ä¼˜åŒ–
```python
# ä»»åŠ¡ç»“æœæ¸…ç†ç­–ç•¥
- å®Œæˆä»»åŠ¡ä¿ç•™7å¤©
- å¤±è´¥ä»»åŠ¡ä¿ç•™30å¤©
- å¤§ç»“æœæ•°æ®å¼‚æ­¥æ¸…ç†
```

## ğŸš€ éƒ¨ç½²é…ç½®

### ç¯å¢ƒå˜é‡
```bash
# ä»»åŠ¡ç³»ç»Ÿé…ç½®
TASK_MAX_CPU_WORKERS=4
TASK_MAX_IO_WORKERS=16
TASK_DEFAULT_TIMEOUT=300
TASK_MAX_RETRIES=3
TASK_CLEANUP_DAYS=7
```

---

**æ–‡æ¡£çŠ¶æ€**: è®¾è®¡å®Œæˆï¼Œå‡†å¤‡å®æ–½  
**ä¸‹ä¸€æ­¥**: å¼€å§‹ç¼–ç å®ç°å„ä¸ªç»„ä»¶  
**é¢„è®¡å®Œæˆ**: 1å¤©å†…å®Œæˆæ ¸å¿ƒåŠŸèƒ½
