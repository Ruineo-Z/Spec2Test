# 数据库配置指南

**版本**: v1.0.0  
**更新时间**: 2025-01-15  
**适用版本**: PostgreSQL 16, SQLite 3.x  

## 🎯 数据库选择策略

### 推荐配置
```bash
# 生产环境: PostgreSQL 16
DATABASE_URL="postgresql://spec2test_user:secure_password@localhost:5432/spec2test"

# 开发环境: PostgreSQL 16 (推荐) 或 SQLite (可选)
DATABASE_URL="postgresql://spec2test_user:dev_password@localhost:5432/spec2test_dev"
# DATABASE_URL="sqlite:///./spec2test_dev.db"

# 测试环境: SQLite (快速重置)
TEST_DATABASE_URL="sqlite:///./test_spec2test.db"
```

## 🐘 PostgreSQL 16 配置

### 1. 安装PostgreSQL 16

#### Ubuntu/Debian
```bash
# 添加PostgreSQL官方仓库
sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
sudo apt update

# 安装PostgreSQL 16
sudo apt install -y postgresql-16 postgresql-contrib-16 postgresql-client-16
```

#### CentOS/RHEL
```bash
# 安装PostgreSQL 16仓库
sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-8-x86_64/pgdg-redhat-repo-latest.noarch.rpm

# 安装PostgreSQL 16
sudo yum install -y postgresql16-server postgresql16-contrib
sudo /usr/pgsql-16/bin/postgresql-16-setup initdb
sudo systemctl enable postgresql-16
sudo systemctl start postgresql-16
```

#### macOS
```bash
# 使用Homebrew
brew install postgresql@16
brew services start postgresql@16
```

### 2. 数据库和用户创建

```bash
# 切换到postgres用户
sudo -u postgres psql

# 创建数据库用户
CREATE USER spec2test_user WITH PASSWORD 'your_secure_password';

# 创建生产数据库
CREATE DATABASE spec2test OWNER spec2test_user;

# 创建开发数据库
CREATE DATABASE spec2test_dev OWNER spec2test_user;

# 创建测试数据库
CREATE DATABASE spec2test_test OWNER spec2test_user;

# 授予权限
GRANT ALL PRIVILEGES ON DATABASE spec2test TO spec2test_user;
GRANT ALL PRIVILEGES ON DATABASE spec2test_dev TO spec2test_user;
GRANT ALL PRIVILEGES ON DATABASE spec2test_test TO spec2test_user;

# 退出
\q
```

### 3. PostgreSQL 16 性能配置

```bash
# 编辑配置文件
sudo vim /etc/postgresql/16/main/postgresql.conf
```

```ini
# 连接配置
listen_addresses = 'localhost'          # 监听地址
port = 5432                             # 端口
max_connections = 100                   # 最大连接数

# 内存配置 (根据服务器内存调整)
shared_buffers = 256MB                  # 共享缓冲区 (25% of RAM)
effective_cache_size = 1GB              # 有效缓存大小 (75% of RAM)
work_mem = 4MB                          # 工作内存 (per connection)
maintenance_work_mem = 64MB             # 维护工作内存

# WAL配置
wal_buffers = 16MB                      # WAL缓冲区
checkpoint_completion_target = 0.9      # 检查点完成目标
max_wal_size = 1GB                      # 最大WAL大小
min_wal_size = 80MB                     # 最小WAL大小

# 查询优化
random_page_cost = 1.1                  # SSD优化
effective_io_concurrency = 200          # SSD并发IO

# 日志配置
logging_collector = on                  # 启用日志收集
log_directory = 'log'                   # 日志目录
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_statement = 'mod'                   # 记录修改语句
log_min_duration_statement = 1000       # 记录慢查询 (1秒+)
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '

# 统计信息
track_activities = on                   # 跟踪活动
track_counts = on                       # 跟踪计数
track_io_timing = on                    # 跟踪IO时间
```

```bash
# 重启PostgreSQL应用配置
sudo systemctl restart postgresql-16
```

### 4. 连接测试

```bash
# 测试连接
psql -h localhost -U spec2test_user -d spec2test -c "SELECT version();"

# 测试Python连接
python -c "
import asyncio
import asyncpg

async def test_connection():
    conn = await asyncpg.connect('postgresql://spec2test_user:password@localhost:5432/spec2test')
    version = await conn.fetchval('SELECT version()')
    print(f'Connected to: {version}')
    await conn.close()

asyncio.run(test_connection())
"
```

## 💾 SQLite 配置 (开发可选)

### 1. SQLite优势
```bash
✅ 零配置，开箱即用
✅ 单文件数据库，便于备份和移动
✅ 适合快速开发和原型验证
✅ 无需额外服务进程
✅ 支持大部分SQL标准
```

### 2. SQLite配置
```python
# SQLite连接配置
DATABASE_URL = "sqlite:///./spec2test.db"

# SQLite连接参数
SQLITE_CONFIG = {
    "echo": False,
    "connect_args": {
        "check_same_thread": False,  # 允许多线程
        "timeout": 20,               # 连接超时
        "isolation_level": None      # 自动提交模式
    }
}
```

### 3. SQLite性能优化
```sql
-- 性能优化PRAGMA设置
PRAGMA journal_mode = WAL;          -- 启用WAL模式
PRAGMA synchronous = NORMAL;        -- 同步模式
PRAGMA cache_size = 10000;          -- 缓存大小
PRAGMA temp_store = memory;         -- 临时存储在内存
PRAGMA mmap_size = 268435456;       -- 内存映射大小 (256MB)
```

## 🔄 数据库切换指南

### 1. 从SQLite切换到PostgreSQL

```bash
# 1. 安装和配置PostgreSQL
# (参考上面的PostgreSQL配置)

# 2. 导出SQLite数据
sqlite3 spec2test.db .dump > spec2test_backup.sql

# 3. 转换SQL语法 (如需要)
# SQLite -> PostgreSQL语法差异处理

# 4. 修改环境变量
vim .env
# DATABASE_URL="postgresql://spec2test_user:password@localhost:5432/spec2test"

# 5. 运行迁移
alembic upgrade head

# 6. 导入数据 (如需要)
psql -h localhost -U spec2test_user -d spec2test < converted_data.sql

# 7. 重启应用
sudo systemctl restart spec2test
```

### 2. 从PostgreSQL切换到SQLite

```bash
# 1. 导出PostgreSQL数据
pg_dump -h localhost -U spec2test_user -d spec2test > spec2test_backup.sql

# 2. 修改环境变量
vim .env
# DATABASE_URL="sqlite:///./spec2test.db"

# 3. 运行迁移
alembic upgrade head

# 4. 转换和导入数据 (如需要)
# PostgreSQL -> SQLite语法转换

# 5. 重启应用
sudo systemctl restart spec2test
```

## 🔧 数据库维护

### PostgreSQL维护

```bash
# 1. 数据库备份
pg_dump -h localhost -U spec2test_user -d spec2test > backup_$(date +%Y%m%d).sql
gzip backup_$(date +%Y%m%d).sql

# 2. 数据库恢复
psql -h localhost -U spec2test_user -d spec2test < backup_20250115.sql

# 3. 数据库优化
psql -h localhost -U spec2test_user -d spec2test -c "VACUUM ANALYZE;"

# 4. 查看数据库大小
psql -h localhost -U spec2test_user -d spec2test -c "
SELECT 
    pg_size_pretty(pg_database_size('spec2test')) as database_size,
    pg_size_pretty(pg_total_relation_size('tasks')) as tasks_table_size;
"

# 5. 查看连接数
psql -h localhost -U spec2test_user -d spec2test -c "
SELECT count(*) as active_connections 
FROM pg_stat_activity 
WHERE state = 'active';
"
```

### SQLite维护

```bash
# 1. 数据库备份
cp spec2test.db spec2test_backup_$(date +%Y%m%d).db

# 2. 数据库优化
sqlite3 spec2test.db "VACUUM;"
sqlite3 spec2test.db "ANALYZE;"

# 3. 查看数据库大小
ls -lh spec2test.db

# 4. 数据库完整性检查
sqlite3 spec2test.db "PRAGMA integrity_check;"
```

## 📊 性能对比

### PostgreSQL 16 vs SQLite

| 特性 | PostgreSQL 16 | SQLite |
|------|---------------|---------|
| 并发写入 | ✅ 优秀 | ⚠️ 有限 |
| 并发读取 | ✅ 优秀 | ✅ 良好 |
| 数据完整性 | ✅ 完整ACID | ✅ 完整ACID |
| 复杂查询 | ✅ 优秀 | ✅ 良好 |
| 数据类型 | ✅ 丰富 | ⚠️ 有限 |
| 扩展性 | ✅ 优秀 | ❌ 有限 |
| 部署复杂度 | ⚠️ 中等 | ✅ 简单 |
| 资源消耗 | ⚠️ 较高 | ✅ 很低 |
| 生产就绪 | ✅ 完全 | ⚠️ 小规模 |

### 选择建议

```bash
# 选择PostgreSQL的场景:
✅ 生产环境部署
✅ 高并发访问需求
✅ 复杂查询和分析
✅ 数据一致性要求高
✅ 需要扩展性

# 选择SQLite的场景:
✅ 快速开发和原型
✅ 单用户或低并发
✅ 简单的数据操作
✅ 嵌入式应用
✅ 零配置需求
```

## 🚨 注意事项

### 数据类型差异
```python
# PostgreSQL支持原生JSON类型
input_data = Column(postgresql.JSON)

# SQLite将JSON存储为TEXT
input_data = Column(Text)  # 需要手动序列化/反序列化
```

### 并发限制
```python
# PostgreSQL: 支持高并发读写
# SQLite: 同时只能有一个写操作

# 在高并发场景下，SQLite可能出现:
# sqlite3.OperationalError: database is locked
```

### 迁移兼容性
```python
# 确保Alembic迁移脚本兼容两种数据库
def upgrade():
    bind = op.get_bind()
    if bind.dialect.name == 'postgresql':
        # PostgreSQL特定操作
        pass
    elif bind.dialect.name == 'sqlite':
        # SQLite特定操作
        pass
```

---

**维护说明**: 本指南随数据库版本更新而更新  
**技术支持**: 遇到问题请参考故障排除或提交Issue  
**推荐配置**: 生产环境使用PostgreSQL 16，开发环境可选SQLite
